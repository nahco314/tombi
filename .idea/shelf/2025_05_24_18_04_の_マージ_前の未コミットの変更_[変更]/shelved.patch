Index: tombi.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tombi.toml b/_tombi.toml
rename from tombi.toml
rename to _tombi.toml
--- a/tombi.toml	(revision bd570320c965d35d76337e1475f03ea43db38e67)
+++ b/_tombi.toml	(date 1748072692794)
@@ -10,11 +10,8 @@
 
 [lint]
 
-[lsp]
-document-link = { enabled = true }
-
 [schema]
-enabled = true
+enabled = false
 catalog = { path = "https://www.schemastore.org/api/json/catalog.json" }
 
 [[schemas]]
@@ -37,3 +34,6 @@
 root = "tool.taskipy"
 path = "schemas/partial-taskipy.schema.json"
 include = ["pyproject.toml"]
+
+[lsp]
+document-link = { enabled = true }
Index: rust/serde_tombi/src/de.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>mod error;\n\npub use error::Error;\nuse itertools::Either;\nuse serde::de::DeserializeOwned;\nuse tombi_ast::AstNode;\nuse tombi_document::IntoDocument;\nuse tombi_document_tree::IntoDocumentTreeAndErrors;\nuse tombi_schema_store::{SchemaStore, SourceSchema};\nuse tombi_toml_version::TomlVersion;\nuse typed_builder::TypedBuilder;\n\n/// Deserialize a TOML string into a Rust data structure.\n///\n/// # Note\n///\n/// This function is not yet implemented and will return an error.\n/// The example below shows the expected usage once implemented.\n///\n/// # Examples\n///\n/// ```\n/// use serde::Deserialize;\n/// use tokio;\n///\n/// #[derive(Deserialize)]\n/// struct Config {\n///     ip: String,\n///     port: u16,\n///     keys: Vec<String>,\n/// }\n///\n/// #[tokio::main]\n/// async fn main() {\n///     let toml = r#\"\n///     ip = \"127.0.0.1\"\n///     port = 8080\n///     keys = [\"key1\", \"key2\"]\n///     \"#;\n///\n///     let config: Config = serde_tombi::from_str_async(toml).await.unwrap();\n/// }\n/// ```\npub async fn from_str_async<T>(toml_text: &str) -> Result<T, crate::de::Error>\nwhere\n    T: DeserializeOwned,\n{\n    Deserializer::new().from_str_async(toml_text).await\n}\n\npub fn from_document<T>(document: tombi_document::Document) -> Result<T, crate::de::Error>\nwhere\n    T: DeserializeOwned,\n{\n    Deserializer::new().from_document(document)\n}\n\n// Actual deserializer implementation\n#[derive(TypedBuilder)]\npub struct Deserializer<'de> {\n    #[builder(default, setter(into, strip_option))]\n    config: Option<&'de ::tombi_config::Config>,\n\n    #[builder(default, setter(into, strip_option))]\n    config_path: Option<&'de std::path::Path>,\n\n    #[builder(default, setter(into, strip_option))]\n    source_path: Option<&'de std::path::Path>,\n\n    #[builder(default, setter(into, strip_option))]\n    schema_store: Option<&'de tombi_schema_store::SchemaStore>,\n}\n\nimpl Default for Deserializer<'_> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Deserializer<'_> {\n    pub fn new() -> Self {\n        Self {\n            config: None,\n            config_path: None,\n            source_path: None,\n            schema_store: None,\n        }\n    }\n\n    pub async fn from_str_async<T>(&self, toml_text: &str) -> Result<T, crate::de::Error>\n    where\n        T: DeserializeOwned,\n    {\n        let toml_version = self.get_toml_version(&toml_text).await?;\n        let parsed = tombi_parser::parse(toml_text, toml_version);\n        let root = tombi_ast::Root::cast(parsed.syntax_node()).expect(\"AST Root must be present\");\n        // Check if there are any parsing errors\n        if !parsed.errors.is_empty() {\n            return Err(crate::de::Error::Parser(parsed.errors));\n        }\n        from_document(self.try_to_document(root, toml_version)?)\n    }\n\n    pub fn from_document<T>(\n        &self,\n        document: tombi_document::Document,\n    ) -> Result<T, crate::de::Error>\n    where\n        T: DeserializeOwned,\n    {\n        Ok(T::deserialize(&document)?)\n    }\n\n    async fn get_toml_version(&self, toml_text: &str) -> Result<TomlVersion, crate::de::Error> {\n        let schema_store = match self.schema_store {\n            Some(schema_store) => schema_store,\n            None => &SchemaStore::new(),\n        };\n\n        let mut toml_version = TomlVersion::default();\n\n        if self.schema_store.is_none() {\n            match self.config {\n                Some(config) => {\n                    if let Some(new_toml_version) = config.toml_version {\n                        toml_version = new_toml_version;\n                    }\n                    if self.schema_store.is_none() {\n                        schema_store.load_config(config, self.config_path).await?;\n                    }\n                }\n                None => {\n                    let (config, config_path) = crate::config::load_with_path()?;\n\n                    if let Some(new_toml_version) = config.toml_version {\n                        toml_version = new_toml_version;\n                    }\n\n                    schema_store\n                        .load_config(&config, config_path.as_deref())\n                        .await?;\n                }\n            }\n        }\n\n        let parsed = tombi_parser::parse_document_header_comments(toml_text)\n            .cast::<tombi_ast::Root>()\n            .expect(\"AST Root must be present\");\n        let root = parsed.tree();\n\n        if let Some(source_path) = self.source_path {\n            match schema_store\n                .try_get_source_schema_from_ast(&root, Some(Either::Right(source_path)))\n                .await\n            {\n                Ok(Some(SourceSchema {\n                    root_schema: Some(root_schema),\n                    ..\n                })) => {\n                    if let Some(new_toml_version) = root_schema.toml_version() {\n                        toml_version = new_toml_version;\n                    }\n                }\n                Err((error, url_range)) => {\n                    return Err(crate::de::Error::DocumentCommentSchemaUrl { error, url_range });\n                }\n                _ => {}\n            }\n        }\n\n        Ok(toml_version)\n    }\n\n    pub(crate) fn try_to_document(\n        &self,\n        root: tombi_ast::Root,\n        toml_version: TomlVersion,\n    ) -> Result<tombi_document::Document, crate::de::Error> {\n        // Convert the AST to a document tree\n        let (document_tree, errors) = root.into_document_tree_and_errors(toml_version).into();\n\n        // Check for errors during document tree construction\n        if !errors.is_empty() {\n            return Err(crate::de::Error::DocumentTree(errors));\n        }\n\n        // Convert to a Document\n        Ok(document_tree.into_document(toml_version))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::{DateTime, TimeZone, Utc};\n    use indexmap::{indexmap, IndexMap};\n    use serde::Deserialize;\n    use tombi_test_lib::project_root_path;\n\n    #[tokio::test]\n    async fn test_deserialize_struct() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct Test {\n            int: i32,\n            float: f64,\n            string: String,\n            bool: bool,\n            opt: Option<String>,\n        }\n\n        let toml = r#\"\nint = 42\nfloat = 3.141592653589793\nstring = \"hello\"\nbool = true\nopt = \"optional\"\n\"#;\n\n        let expected = Test {\n            int: 42,\n            float: std::f64::consts::PI,\n            string: \"hello\".to_string(),\n            bool: true,\n            opt: Some(\"optional\".to_string()),\n        };\n\n        let result: Test = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_nested_struct() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct Nested {\n            value: String,\n        }\n\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct Test {\n            nested: Nested,\n            simple_value: i32,\n        }\n\n        let toml = r#\"\nsimple_value = 42\n\n[nested]\nvalue = \"nested value\"\n\"#;\n\n        let expected = Test {\n            nested: Nested {\n                value: \"nested value\".to_string(),\n            },\n            simple_value: 42,\n        };\n\n        let result: Test = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_array() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct SimpleArrayTest {\n            values: Vec<i32>,\n        }\n\n        let toml = r#\"values = [1, 2, 3]\"#;\n\n        let expected = SimpleArrayTest {\n            values: vec![1, 2, 3],\n        };\n\n        let result: SimpleArrayTest = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_map() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct MapTest {\n            string_map: IndexMap<String, String>,\n            int_map: IndexMap<String, i32>,\n        }\n\n        let toml = r#\"\n[string_map]\nkey1 = \"value1\"\nkey2 = \"value2\"\n\n[int_map]\none = 1\ntwo = 2\nthree = 3\n\"#;\n\n        let expected = MapTest {\n            string_map: indexmap! {\n                \"key1\".to_string() => \"value1\".to_string(),\n                \"key2\".to_string() => \"value2\".to_string(),\n            },\n            int_map: indexmap! {\n                \"one\".to_string() => 1,\n                \"two\".to_string() => 2,\n                \"three\".to_string() => 3,\n            },\n        };\n\n        let result: MapTest = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_enum() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        enum SimpleEnum {\n            Variant1,\n        }\n\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct EnumTest {\n            enum_value: SimpleEnum,\n        }\n\n        let toml = r#\"enum_value = \"Variant1\"\"#;\n\n        let expected = EnumTest {\n            enum_value: SimpleEnum::Variant1,\n        };\n\n        let result: EnumTest = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_datetime() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct DateTimeTest {\n            created_at: DateTime<Utc>,\n            updated_at: DateTime<Utc>,\n        }\n\n        let toml = r#\"\ncreated_at = \"2023-05-15T10:30:00Z\"\nupdated_at = \"2023-07-20T14:45:30Z\"\n\"#;\n\n        let expected = DateTimeTest {\n            created_at: Utc.with_ymd_and_hms(2023, 5, 15, 10, 30, 0).unwrap(),\n            updated_at: Utc.with_ymd_and_hms(2023, 7, 20, 14, 45, 30).unwrap(),\n        };\n\n        let result: DateTimeTest = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_option() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct OptionTest {\n            some: Option<String>,\n            none: Option<String>,\n        }\n\n        let toml = r#\"some = \"optional\"\"#;\n\n        let expected = OptionTest {\n            some: Some(\"optional\".to_string()),\n            none: None,\n        };\n\n        let result: OptionTest = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_empty_containers() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct EmptyContainers {\n            empty_array: Vec<i32>,\n            empty_map: IndexMap<String, String>,\n        }\n\n        let toml = r#\"\nempty_array = []\nempty_map = {}\n\"#;\n\n        let expected = EmptyContainers {\n            empty_array: vec![],\n            empty_map: IndexMap::new(),\n        };\n\n        let result: EmptyContainers = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_special_characters() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct SpecialChars {\n            newlines: String,\n            quotes: String,\n            unicode: String,\n            escape_chars: String,\n        }\n\n        let toml = r#\"\nnewlines = \"line1\\nline2\\nline3\"\nquotes = \"\\\"quoted\\\"\"\nunicode = \"日本語の文字列\"\nescape_chars = \"\\\\t\\\\n\\\\r\\\\\\\"\"\n\"#;\n\n        let expected = SpecialChars {\n            newlines: \"line1\\nline2\\nline3\".to_string(),\n            quotes: \"\\\"quoted\\\"\".to_string(),\n            unicode: \"日本語の文字列\".to_string(),\n            escape_chars: \"\\\\t\\\\n\\\\r\\\\\\\"\".to_string(),\n        };\n\n        let result: SpecialChars = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_numeric_boundaries() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct NumericBoundaries {\n            min_i32: i32,\n            max_i32: i32,\n            min_f64: f64,\n            max_f64: f64,\n            zero: f64,\n            negative_zero: f64,\n        }\n\n        let toml = r#\"\nmin_i32 = -2147483648\nmax_i32 = 2147483647\nmin_f64 = -1.7976931348623157e308\nmax_f64 = 1.7976931348623157e308\nzero = 0.0\nnegative_zero = -0.0\n\"#;\n\n        let expected = NumericBoundaries {\n            min_i32: i32::MIN,\n            max_i32: i32::MAX,\n            min_f64: f64::MIN,\n            max_f64: f64::MAX,\n            zero: 0.0,\n            negative_zero: -0.0,\n        };\n\n        let result: NumericBoundaries = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_complex_nested() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct Inner {\n            value: String,\n            numbers: Vec<i32>,\n        }\n\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct Middle {\n            inner: Inner,\n            map: IndexMap<String, Inner>,\n        }\n\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct ComplexNested {\n            middle: Middle,\n            array_of_maps: Vec<IndexMap<String, String>>,\n        }\n\n        let toml = r#\"\n[middle.inner]\nvalue = \"nested value\"\nnumbers = [1, 2, 3]\n\n[middle.map.key1]\nvalue = \"value1\"\nnumbers = [4, 5, 6]\n\n[middle.map.key2]\nvalue = \"value2\"\nnumbers = [7, 8, 9]\n\n[[array_of_maps]]\nkey1 = \"value1\"\nkey2 = \"value2\"\n\n[[array_of_maps]]\nkey3 = \"value3\"\nkey4 = \"value4\"\n\"#;\n\n        let expected = ComplexNested {\n            middle: Middle {\n                inner: Inner {\n                    value: \"nested value\".to_string(),\n                    numbers: vec![1, 2, 3],\n                },\n                map: indexmap! {\n                    \"key1\".to_string() => Inner {\n                        value: \"value1\".to_string(),\n                        numbers: vec![4, 5, 6],\n                    },\n                    \"key2\".to_string() => Inner {\n                        value: \"value2\".to_string(),\n                        numbers: vec![7, 8, 9],\n                    },\n                },\n            },\n            array_of_maps: vec![\n                indexmap! {\n                    \"key1\".to_string() => \"value1\".to_string(),\n                    \"key2\".to_string() => \"value2\".to_string(),\n                },\n                indexmap! {\n                    \"key3\".to_string() => \"value3\".to_string(),\n                    \"key4\".to_string() => \"value4\".to_string(),\n                },\n            ],\n        };\n\n        let result: ComplexNested = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_mixed_type_array() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct MixedTypeArray {\n            mixed: Vec<MixedType>,\n        }\n\n        #[derive(Debug, Deserialize, PartialEq)]\n        #[serde(untagged)]\n        enum MixedType {\n            Integer(i32),\n            Float(f64),\n            String(String),\n            Boolean(bool),\n        }\n\n        let toml = r#\"\nmixed = [42, 3.14, \"hello\", true]\n\"#;\n\n        let expected = MixedTypeArray {\n            mixed: vec![\n                MixedType::Integer(42),\n                MixedType::Float(3.14),\n                MixedType::String(\"hello\".to_string()),\n                MixedType::Boolean(true),\n            ],\n        };\n\n        let result: MixedTypeArray = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_default_values() {\n        #[derive(Debug, Deserialize, PartialEq)]\n        struct DefaultValues {\n            #[serde(default)]\n            optional_string: String,\n            #[serde(default = \"default_i32\")]\n            optional_i32: i32,\n            #[serde(default = \"default_vec\")]\n            optional_vec: Vec<String>,\n        }\n\n        fn default_i32() -> i32 {\n            42\n        }\n\n        fn default_vec() -> Vec<String> {\n            vec![\"default\".to_string()]\n        }\n\n        let toml = r#\"\noptional_string = \"provided\"\n\"#;\n\n        let expected = DefaultValues {\n            optional_string: \"provided\".to_string(),\n            optional_i32: 42,\n            optional_vec: vec![\"default\".to_string()],\n        };\n\n        let result: DefaultValues = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n        pretty_assertions::assert_eq!(result, expected);\n    }\n\n    #[tokio::test]\n    async fn test_empty_tombi_config() {\n        tombi_test_lib::init_tracing();\n        let toml = r#\"\"#;\n\n        let config: tombi_config::Config = from_str_async(toml)\n            .await\n            .expect(\"TOML deserialization failed\");\n\n        pretty_assertions::assert_eq!(config, tombi_config::Config::default());\n    }\n\n    #[tokio::test]\n    async fn test_deserialize_actual_tombi_config() {\n        let config_path = project_root_path().join(\"tombi.toml\");\n        let config = crate::config::from_str(\n            &std::fs::read_to_string(&config_path).unwrap(),\n            &config_path,\n        )\n        .expect(\"Failed to parse tombi.toml\");\n\n        // Verify the parsed values\n        pretty_assertions::assert_eq!(\n            config.toml_version,\n            Some(tombi_toml_version::TomlVersion::V1_0_0)\n        );\n        pretty_assertions::assert_eq!(config.exclude, Some(vec![\"node_modules/**/*\".to_string()]));\n        assert!(config.format.is_some());\n        assert!(config.lint.is_some());\n        assert!(config.lsp().is_some());\n        assert!(config.schema.is_some());\n        assert!(config.schemas.is_some());\n\n        let schema = config.schema.unwrap();\n        pretty_assertions::assert_eq!(\n            schema.enabled,\n            Some(tombi_config::BoolDefaultTrue::default())\n        );\n\n        let schemas = config.schemas.unwrap();\n        pretty_assertions::assert_eq!(schemas.len(), 5);\n\n        // Verify the first schema\n        let first_schema = &schemas[0];\n        pretty_assertions::assert_eq!(first_schema.path(), \"tombi.schema.json\");\n        pretty_assertions::assert_eq!(first_schema.include(), &[\"tombi.toml\"]);\n\n        // Verify the last schema\n        let last_schema = &schemas[4];\n        pretty_assertions::assert_eq!(last_schema.path(), \"schemas/partial-taskipy.schema.json\");\n        pretty_assertions::assert_eq!(last_schema.include(), &[\"pyproject.toml\"]);\n        pretty_assertions::assert_eq!(last_schema.root(), Some(\"tool.taskipy\"));\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rust/serde_tombi/src/de.rs b/rust/serde_tombi/src/de.rs
--- a/rust/serde_tombi/src/de.rs	(revision bd570320c965d35d76337e1475f03ea43db38e67)
+++ b/rust/serde_tombi/src/de.rs	(date 1748072720038)
@@ -640,7 +640,7 @@
 
     #[tokio::test]
     async fn test_deserialize_actual_tombi_config() {
-        let config_path = project_root_path().join("tombi.toml");
+        let config_path = project_root_path().join("../../../_tombi.toml");
         let config = crate::config::from_str(
             &std::fs::read_to_string(&config_path).unwrap(),
             &config_path,
